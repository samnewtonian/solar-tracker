# solar-tracker

Solar angle calculation library for computing optimal solar panel angles based on date, time, and geographic position. Supports fixed installations, single-axis trackers, and dual-axis trackers.

Implemented in Clojure (reference implementation), Python, and Rust. Uses standard solar position algorithms (NOAA / Duffie & Beckman).

> **API divergence:** The Clojure and Python implementations have been updated to accept timezone-aware `ZonedDateTime` and `datetime` objects, respectively. The Rust port still use the old 8-argument `solar_position` signature and will be updated to match.

**Important**: This codebase is almost entirely generated by Claude Code. While I've made many efforts to make sure it keeps reviewing its own code (`correctness, factoring, and optimization` has been typed a lot recently) I have not done a Mk I Eyeball review yet. As such, while the API is meant to be pure (as in pure functions), use at your own risk. Or help clean it up :)

## Features

- **Solar position** — zenith, altitude, azimuth, declination, hour angle, equation of time
- **Dual-axis tracking** — tilt and panel azimuth to point directly at the sun
- **Single-axis tracking** — rotation angle for north-south horizontal trackers
- **Fixed installations** — optimal annual tilt and seasonal adjustments
- **Lookup tables** — precomputed daylight-only tables with interpolated lookups

## Requirements

**Clojure:** Clojure 1.12+, Java 11+

**Python:** Python 3.11+ (no external dependencies; pytest for dev)

**Rust:** Rust 1.80+ (no external dependencies; std only)

## Usage

### Clojure (reference implementation)

Add as a git dependency in your `deps.edn` (use `:deps/root` since the Clojure source lives under `clojure/`):

```clojure
{:deps
 {io.github.samnewtonian/solar-tracker
  {:git/sha "..."
   ;; Optional: :git/tag "v0.1.0"
   :deps/root "clojure"}}}
```

Then in your code:

```clojure
(require '[com.kardashevtypev.solar.angles :as sa])
(import '[java.time ZonedDateTime ZoneId])

;; Calculate solar position for Springfield, IL on March 21 at noon Central Time
;; Pass any timezone-aware ZonedDateTime — converted to UTC internally
(sa/solar-position 39.8 -89.6
                   (ZonedDateTime/of 2026 3 21 12 0 0 0 (ZoneId/of "America/Chicago")))
;; => {:day-of-year 80
;;     :declination -0.40
;;     :equation-of-time -7.86
;;     :local-solar-time 11.84
;;     :hour-angle -2.36
;;     :zenith 40.26
;;     :altitude 49.74
;;     :azimuth 176.34}

;; Dual-axis tracker angles
(let [dt (ZonedDateTime/of 2026 6 21 14 30 0 0 (ZoneId/of "America/Chicago"))]
  (sa/dual-axis-angles (sa/solar-position 39.8 -89.6 dt)))
;; => {:tilt <zenith>, :panel-azimuth <facing-sun>}

;; Single-axis tracker rotation
(let [dt (ZonedDateTime/of 2026 3 21 15 0 0 0 (ZoneId/of "America/Chicago"))
      pos (sa/solar-position 39.8 -89.6 dt)]
  (sa/single-axis-tilt pos 39.8))

;; Optimal fixed tilt for a latitude
(sa/optimal-fixed-tilt 39.8)   ;; => 33.3°

;; Seasonal tilt adjustments
(sa/seasonal-tilt-adjustment 40.0 :summer)  ;; => 25.0°
(sa/seasonal-tilt-adjustment 40.0 :winter)  ;; => 55.0°
```

### Python

```python
from solar_tracker import solar_position, dual_axis_angles, single_axis_tilt
from solar_tracker import optimal_fixed_tilt, seasonal_tilt_adjustment, Season

from datetime import datetime
from zoneinfo import ZoneInfo

# ZoneInfo handles DST automatically
pos = solar_position(39.8, -89.6, datetime(2026, 3, 21, 12, 0, tzinfo=ZoneInfo("America/Chicago")))

# Dual-axis tracker angles
da = dual_axis_angles(pos)
# DualAxisAngles(tilt=..., panel_azimuth=...)

# Single-axis tracker rotation
single_axis_tilt(pos, 39.8)

# Optimal fixed tilt for a latitude
optimal_fixed_tilt(39.8)   # => 33.3°

# Seasonal tilt adjustments
seasonal_tilt_adjustment(40.0, Season.SUMMER)  # => 25.0°
seasonal_tilt_adjustment(40.0, Season.WINTER)  # => 55.0°
```

### Rust (old API — pending update)

Add as a dependency in your `Cargo.toml`:

```toml
[dependencies]
solar_tracker = { git = "https://github.com/samnewtonian/solar-tracker", subdirectory = "rust" }
```

Then in your code:

```rust
use solar_tracker::*;

// NOTE: Rust still uses the old 8-arg API with std_meridian.
// Pass local standard time (not DST) and the standard meridian for your timezone.
let pos = solar_position(39.8, -89.6, 2026, 3, 21, 12, 0, -90.0);
// pos.zenith ≈ 40.26, pos.altitude ≈ 49.74, pos.azimuth ≈ 176.34

// Dual-axis tracker angles
let da = dual_axis_angles(&pos);
// da.tilt, da.panel_azimuth

// Single-axis tracker rotation
let pos = solar_position(39.8, -89.6, 2026, 3, 21, 15, 0, -90.0);
let rotation = single_axis_tilt(&pos, 39.8);

// Optimal fixed tilt for a latitude
optimal_fixed_tilt(39.8); // => 33.3°

// Seasonal tilt adjustments
seasonal_tilt_adjustment(40.0, Season::Summer); // => 25.0°
seasonal_tilt_adjustment(40.0, Season::Winter); // => 55.0°
```

## API Reference

The Clojure implementation is the reference. Python and Rust naming follows language conventions (snake_case, `&` references in Rust). Clojure uses kebab-case (e.g. `solar-position`).

### Core Solar Position (`angles`)

**Clojure/Python:**

| Function | Description |
|----------|-------------|
| `solar-position(lat, lon, ZonedDateTime)` | Full solar position; converts to UTC internally |
| `solar-angles-at(lat, decl, correction, utc-hours)` | Angles from precomputed day-constants and UTC time |
| `utc-lst-correction(longitude, eot)` | UTC→LST correction in hours (constant per day) |
| `leap-year?(year)` | Leap year predicate |
| `days-in-months(year)` | Vector of days per month for a given year |
| `day-of-year(year, month, day)` | Calendar date to ordinal day number (1-366) |
| `solar-declination(n)` | Declination angle for day of year |
| `equation-of-time(n)` | Equation of time correction in minutes |
| `hour-angle(local-solar-time)` | Hour angle from local solar time |
| `solar-zenith-angle(lat, decl, hour-angle)` | Zenith angle |
| `solar-altitude(zenith)` | Altitude (complement of zenith) |
| `solar-azimuth(lat, decl, hour-angle)` | Azimuth (0°=N, 90°=E, 180°=S) |

**Rust (old API — pending update):**

| Function | Description |
|----------|-------------|
| `solar_position(lat, lon, year, month, day, hour, minute, std_meridian)` | Full solar position; takes local standard time + std meridian |
| `local_solar_time(local_time, std_meridian, longitude, n)` | Clock time to true solar time |
| `day_of_year(year, month, day)` | Calendar date to day number (1-366) |
| *(remaining functions identical to Clojure)* | |

### Panel Angles (`angles`)

| Function | Description |
|----------|-------------|
| `dual_axis_angles(solar_pos)` | Tilt and panel azimuth for dual-axis tracker |
| `single_axis_tilt(solar_pos, latitude)` | Rotation angle for single-axis N-S tracker |
| `optimal_fixed_tilt(latitude)` | Optimal annual fixed tilt (empirical formula) |
| `seasonal_tilt_adjustment(latitude, season)` | Seasonal tilt; season is `summer`, `winter`, `spring`, or `fall` |

### Lookup Tables (`lookup_table`)

| Function | Description |
|----------|-------------|
| `generate_single_axis_table(config)` | Generate precomputed single-axis table for 365 days |
| `generate_dual_axis_table(config)` | Generate precomputed dual-axis table for 365 days |
| `lookup_single_axis(table, day_of_year, minutes)` | Interpolated single-axis lookup by day and time |
| `lookup_dual_axis(table, day_of_year, minutes)` | Interpolated dual-axis lookup by day and time |
| `estimate_sunrise_sunset(latitude, day_of_year)` | Sunrise/sunset estimate in minutes from midnight |
| `interpolate_angle(a1, a2, fraction)` | Angle interpolation with 360° wraparound handling |
| `table_to_compact(table)` | Strip metadata; return nested lists of angle values |
| `doy_to_month_day(year, doy)` | Day-of-year to (month, day) |
| `minutes_to_time(minutes)` | Minutes since midnight to (hour, minute) |
| `time_to_minutes(hour, minute)` | (hour, minute) to minutes since midnight |
| `intervals_per_day(interval_minutes)` | Number of intervals in a day |

### Conventions

- All angles in degrees (radians used internally only)
- Latitude: positive = North, negative = South
- Longitude: negative = West, positive = East
- Azimuth: 0° = North, 90° = East, 180° = South, 270° = West
- Hour angle: negative = morning, positive = afternoon, 0° = solar noon

## Running Tests

```bash
# Clojure
cd clojure && clj -X:test

# Python
cd python && python -m pytest

# Rust
cd rust && cargo test
```

## References

- [NOAA Solar Calculator methodology](https://gml.noaa.gov/grad/solcalc/calcdetails.html)
- Duffie & Beckman, *Solar Engineering of Thermal Processes*
- PVEducation.org solar position algorithms

## License

Copyright 2026 Kardashev Type V

Licensed under the Apache License, Version 2.0
